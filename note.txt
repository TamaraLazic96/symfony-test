symfony server:start

We use composer to manage PHP dependencies and libraries
For frontend assets NPM on Yarn
-- bootstrap
We need a way to bundle all JS and CSS files into single file for network efficiency
and to min those files

WEBPACK -- for asset bundling -- nodejs library
bundle your JS and CSS libraries

ASSETIC -- written in PHP
it is build on top of webpack

ENCORE
written in nodejs
can be used in any project -- great with symfony
Makes integration the power of Webpack into your Symfony application simpler
npm run dev

There is no Symfony component for DB
It tightly integrated with 3rd party library Doctrine
Doctrine
ORM Object relational Mapping
DBAL Database Abstraction Layer
ODM Object Document Manager

ORM - mapping tables to PHP classes
DBAL - abstraction layer over PHP PDO
ODM - mapping MongoDB documents to PHP classes

ORM
Technique for data querying and manipulating using object oriented mapping
Data model is represented using PHP classes
Database is abstracted -- do not write SQL queries manually

Create a database for project
php bin/console doctrine:database:create
Generate a new entity
php bin/console make:entity MicroPost
End new files are generated:
created: src/Entity/MicroPost.php
created: src/Repository/MicroPostRepository.php

DDL queries -- Data Definition Language (Create Alter Drop)

Migrations are created by:
php bin/console doctrine:migrations:diff

To apply migration you call:
php bin/console doctrine:migrations:migrate

and migration is run and changes are applied on DB
migration_versions - table where we have migration ID and the time when migration is applied

If we want to revert the last migration that was applied:
php bin/console doctrine:migrations:migrate prev

Run next migrations that are not executed yet:
php bin/console doctrine:migrations:migrate next

If we want without questions are we sure, to run or revert migration:
php bin/console doctrine:migrations:migrate --no-interaction

Repository
is a design patter
prevents scattering of SQL queries all around the project
keeps them in one place
Would be single point of access to your data (Single Responsibility Principle)
Hides the details how are fetched or stored in DB
Project does not need to know or care what is the underlying database server (postgres, MySQL)

composer require --dev doctrine/doctrine-fixtures-bundle
this bundle will allow us to create fake data (fixtures)
php bin/console doctrine:fixtures:load
every time you load fixtures all the data from all the tables are purged
then the fixture class is called
php bin/console doctrine:fixtures:load --help
php bin/console doctrine:fixtures:load --purge-with-truncate
purge the database with resetting primary keys (the first ID is 1 again) - IDs are reset

Entity is an object with identity, any regular PHP class
Id could be number hash or a string
-- not contain fine methods -- proxy classes
-- all entity properties that are to be persisted must be private or protected
can be abstract or concrete class
-- constructor is only called when you directly create this class with new keyword
-- Doctrine never call Entity constructor
Entity manager is a central point of doctrine that manages entities and their state
persist method on new entity or remove marks entity to be persisted or removed by doctrine but does not
perform any of queries before flush
unit of work is similar to the database concept of transaction
work inside entity manager
close() -- all persist remove and changes made to entity will not be persisted
identity map -- keeps the track of all entities loaded from DB using repository method find()
calling find(1) changing it calling again find(1) -> return same instance of Entity with applied changes
clear() before find() and returns from DB
Internal doctrine entity states
MANAGED - entity is associated with Entity manager but is not removed
REMOVED - when you call remove on entity and removed on flush
DETACHED - has persist state but is not associated with entity manager
NEW - not persisted nor ID and is not associated with EntityManager
when you use new and before persist on it

SECURITY in symfony
Authentication?
- is a process of verifying if someone really is who he claims he is
HTML - login form
HTTP basic - prompt
tokens - OAuth or JWT tokens
Authorization?
- is a set of rules that determine who is allowed to do what
user role - user with certain role can do a certain thing
Configuration concepts
Firewalls - how users login to app - auth
Encoders - how pass is encoded
User Providers - how users are loaded - in memory , DB or else
Access Control - restrict certain parts of app to specific users
Security code concepts
User - an entity holding currently auth user
Role - assign to user
Role hierarchy - some roles might extend others
Voter - is an object can decide if certain user, having a certain role can perform some actions
Voter is the preferred way to implement ACL (Access Control List)

symfony uses security objects to verify permission of certain user to perform certain action
each time you call is granted on checker with might be call n controller or in the twig templates
voters are created by extending base voter class
voter has typically 2 methods, one to check if it should be used on certain action and second to actually verify permissions
voter simply checks if action is allowed on the subject
action edit delete object micropost
AFFIRMATIVE (default) - grant access to certain subject as soon as there is one voter granting access
CONSENSUS - grant if more then one voter grants access
UNANIMOUS - only grant access if no voter is denied it

LIFECYCLE CALLBACK
- is a method that would be called when certain event occurs in doctrine
The events defined are:
pre/post Remove, pre/post Persist, pre/Post Update ...
- apply some additional logic when something happens (doctrine)
@ORM\HasLifecycleCallbacks() -- on entity
@ORM\PrePersist() -- on callback

ManyToMany - self referencing relationship (User entity)

PersistentCollection - get assigned when doctrine is fetching (collections)
ArrayCollection -
All is implemented in Collection
contains - first fetches records from data base then check is the entity in collection
count - if the records are fetched from DB then calls count of the related records

*** ArrayCollection vs PersistentCollection vs Collection ***

Event dispatcher
- provides means for your application components to send events and other
components listen and react to them
RegisterController dispatches the user.register event
the UserSubscriber listen to the user.register event, and sends a welcome mail

Swift Mailer - component - for sending mails
composer require mailer

composer require translator
xlf same as xml
<source> original
<target> translator
php bin/console debug:translation fr

What session is and what it is used for
HTTP protocol is stateless, that means it does not keep any state
Each HTTP req is handled individually, the HTTP server does not keep track of HTTP req made by single user
Since we need a way to keep track of the user that is sessions for!
PHP creates unique session ID for each user visiting the site, and then the user session ID is stored in cookie
With each subsequent req the session ID is sent from cookie back to the web server

PHP stores each user session in a file by default
PHP sessions are not started by default(unless configured otherwise in php.ini)
The default session ID name is PHPSESSID
Typical default PHP session lifetime is 24 minutes (unless configured otherwise)
There is a global variable $_SESSION that lets you read and write session data

How does symfony handle sessions
Session class implementing SessionInterface
Abstracts $_SESSION variable, you should not use it for session management
You can configure how session data is stored, by default symfony will use native file storage
Session data can also be stored in a database

DB or files?
small websites - file storage
Bigger web sites (need scaling and run on many server instances) will benefit from DB storage
Memcache or Redis for session storage, since session is basically a key value storage
(when app is behind a load balancer)

php bin/console doctrine:migrations:generate
generate an empty migration (add y yourself some SQL)

Unit tests
- it is a PHP class that test another PHP class
- php class is called a unit
- unit test purpose is to call public methods of php class and to match the result of what is expected

Symfony uses PHPUnit framework
/test dir
- should replicate the original dir structure of your class being tested
composer require --dev symfony/phpunit-bridge

./vendor/bin/simple-phpunit
php bin/phpunit

Form -- how to say what entity to use: for microPost: 'data_class' => MicroPost::class
Example:
$resolver->setDefaults([
    'data_class' => MicroPost::class
]);
In twig.yaml file you configure for form (FormType) to use bootstrap.
Example:
form_themes: ['bootstrap_4_layout.html.twig']

php bin/console debug:router


















